#!/bin/sh
######################################################################
# @(#) rsync like Time Machine
#
# This script backs up a source directory to local another directory
# by rsync. It supports history and reduce size by hard link like
# Mac OS's Time Machine.
#
#  Author: Tats SHIBATA
# Licenct: http://rewse.jp/license/2011.01.txt
#
# Copyright (c) 2006, 2011 Rewse Lab. All rights reserved.
#
######################################################################

# {{{ Variables

SOURCE_PATH=/tmp/bar

TARGET_PATH=/mnt/foo/bar

MOUNT_PATH=/mnt/foo

LOG=/var/log/backup.log

THRESHOLD=90

# }}}
# {{{ mountpath()

mountpath() {
  if [ "MOUNT_PATH" = "" ]; then
    return 0
  fi

  if [ ! "`mount | grep $MOUNT_PATH`" ]; then
    mount $MOUNT_PATH

    if [ $? -ne 0 ]; then
      echo "[ERROR] Can't mount $MOUNT_PATH" 1>&2
      exit 1
    fi
  fi
}

# }}}
# {{{ umountpath()

umountpath() {
  if [ "MOUNT_PATH" = "" ]; then
    return 0
  fi

  umount $MOUNT_PATH

  if [ $? -ne 0 ]; then
    echo "[ERROR] Can't unmount $MOUNT_PATH" 1>&2
    exit 1
  fi
}

# }}}
# {{{ mktargetdir()

mktargetdir() {
  TARGET_DIR=`date '+%Y%m%dW%VT%H%M%S'`

  mkdir -p $TARGET_PATH/$TARGET_DIR

  if [ $? -ne 0 ]; then
    echo "[ERROR] Can't make $TARGET_PATH/$TARGET_DIR" 1>&2
    exit 1
  fi
}

# {{{ dorsync

dorsync() {
  if [ -d $TARGET_PATH/latest ]; then
    rsync -avz --stats --link-dest=../latest \
      $SOURCE_PATH/ $TARGET_PATH/$TARGET_DIR
  else
    rsync -avz --stats $SOURCE_PATH/ $TARGET_PATH/$TARGET_DIR
  fi

  if [ $? -ne 0 ]; then
    echo "[ERROR] Can't rsync" 1>&2
    exit 1
  fi
}

# }}}
# {{{ mklatest()

mklatest() {
  cd $TARGET_PATH && rm -f latest && ln -s $TARGET_DIR latest && cd -

  if [ $? -ne 0 ]; then
    echo "[ERROR] Can't make $TARGET_PATH/latest" 1>&2
    exit 1
  fi
}

# }}}
# {{{ purgeexcess()

purgeexcess() {
  # should set from $TARGET_DIR instead of date command because $TARGET_DIR
  # date might be diffrent from date command when this script is started
  # just before 0:00 midnight.
  NOW_YEAR=`expr substr $TARGET_DIR 1 4`
  NOW_MONTH=`expr substr $TARGET_DIR 5 2`
  NOW_DAY=`expr substr $TARGET_DIR 7 2`

  LASTMONTH_YEAR=`date --date "$NOW_YEAR-$NOW_MONTH-$NOW_DAY 1 months ago" '+%Y'`
  LASTMONTH_WEEK=`date --date "$NOW_YEAR-$NOW_MONTH-$NOW_DAY 1 months ago" '+%V'`

  for DIR in `ls $TARGET_PATH | egrep -v "$TARGET_DIR|latest"`; do
    if [ ! -d $TARGET_PATH/$DIR ]; then
      # $DIR was already purged by this function
      continue
    fi

    DIR_YEAR=`expr substr $DIR 1 4`
    DIR_WEEK=`expr substr $DIR 10 2`
    DIR_DATE=`expr substr $DIR 1 8`

    if [ $DIR_YEAR -lt $LASTMONTH_YEAR ]; then
      OLDEST=`ls -d $TARGET_PATH/$DIR_YEAR*W$DIR_WEEK* | head -1`

      PURGED_DIR=`ls -d $TARGET_PATH/$DIR_YEAR*W$DIR_WEEK* | grep -v $OLDEST`
    elif [ $DIR_YEAR -eq $LASTMONTH_YEAR -a $DIR_WEEK -le $LASTMONTH_WEEK ]; then
      OLDEST=`ls -d $TARGET_PATH/$DIR_YEAR*W$DIR_WEEK* | head -1`

      PURGED_DIR=`ls -d $TARGET_PATH/$DIR_YEAR*W$DIR_WEEK* | grep -v $OLDEST`
    else
      # $DIR was created within 1 month from now on
      OLDEST=`ls -d $TARGET_PATH/$DIR_DATE* | head -1`

      PURGED_DIR=`ls -d $TARGET_PATH/$DIR_DATE* | grep -v $OLDEST`
    fi

    for DIR in $PURGED_DIR; do
      if [ $DIR == $TARGET_PATH/$TARGET_DIR ]; then
        # Don't purge the just created directory
        continue
      fi

      echo "Purging $DIR..."
      rm -rf $DIR
    done
  done
}

# }}}
# {{{ purgeold()

purgeold() {
  CURRENT_USAGE=`df -P | grep $MOUNT_PATH | awk '{print $5}' | sed 's/%//'`
}

# }}}
# {{{ Trap

trap 'exit 1' 1 2 3 15

# }}}
# {{{ Main

mountpath >> $LOG

mktargetdir >> $LOG

dorsync >> $LOG

mklatest >> $LOG

purgeexcess >> $LOG

# TODO: puregeold >> $LOG

umountpath >> $LOG

cat <<! >> $LOG
[NOTICE] Backup ends: `date`
---------------------------------------------------------------------
!

# }}}
