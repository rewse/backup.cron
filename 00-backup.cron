#!/bin/sh
######################################################################
# @(#) rsync like Time Machine
#
# This script backs up a source directory to local another directory
# by rsync. It supports history and reduce size by hard link like
# Mac OS's Time Machine.
#
#  Author: Tats SHIBATA
# Licenct: http://rewse.jp/license/2011.01.txt
#
# Copyright (c) 2006, 2011 Rewse Lab. All rights reserved.
#
######################################################################
# {{{ now()

now() {
  LANG=C date '+%b %e %T'
}

# }}}
# {{{ umountpath()

umountpath() {
  if [ "$SKIP_MOUNT" = "1" ]; then
    return 0
  fi

  umount $MOUNT_PATH

  if [ $? -ne 0 ]; then
    echo "`now` [WARNING] Can't unmount $MOUNT_PATH [CODE=$?]" >&2
    # no need exit. it's called from myexit
  fi
}

# }}}
# {{{ myeit()

myexit() {
  rm -f /var/lock/subsys/backup.tmp

  if [ $1 -ne 0 ]; then
    echo "`now` [WARNING] Unexpected error [CODE=$1]" >> $LOG

    if [ "$OK_SYNC" != "1" ]; then
      # if $TARGET_PATH and $TARGET_DIR are blank, rm -rf / is called!
      if [ "$TARGET_PATH" != "" -a "$TARGET_DIR" != "" ]; then
        echo "`now` [NOTICE] Removing $TARGET_PATH/$TARGET_DIR..." >> $LOG
        rm -rf $TARGET_PATH/$TARGET_DIR
        rm -f /var/lock/subsys/backup
      else
        echo "`now` [ERROR] Runtime error [CODE=001]" >&2
        # no need exit. it's called at the below
      fi
    fi
  fi

  umountpath

  cat <<! >> $LOG
`now` [NOTICE] Backup ends
---------------------------------------------------------------------
!

  exit $1
}

# }}}
# {{{ validconf()

validconf() {
  if [ ! -d "$SOURCE_PATH" ]; then
    echo "`now` SOURCE_PATH [$SOURCE_PATH] is not found"
    exit 1
  fi

  case "$SKIP_MOUNT" in
    [!01])
      echo "`now` [ERROR] SKIP_MOUNT must be 0 or 1. Actual is $SKIP_MOUNT"
      exit 1
      ;;
  esac

  if [ ! -d "$MOUNT_PATH" -a "$SKIP_MOUNT" -eq 0 ]; then
    echo "`now` [ERROR] MOUNT_PATH [$MOUNT_PATH] is not found"
    exit 1
  fi

  if [ "`grep $MOUNT_PATH /etc/fstab`" == "" -a "$SKIP_MOUNT" -eq 0 ]; then
    echo "`now` [ERROR] MOUNT_PATH [$MOUNT_PATH] is not found on /etc/fstab"
    exit 1
  fi

  if [ "$TARGET_PATH" == "" ]; then
    echo "`now` [ERROR] TARGET_PATH is blank"
    exit 1
  fi

  case "$COMPRESSION" in
    [!01])
      echo "`now` [ERROR] COMPRESSION must be 0 or 1. Acutual is $COMPRESSION"
      exit 1
      ;;
  esac

  if [ "$THRESHOLD" -ge 100 -o "$THRESHOLD" -le 0 ]; then
    echo "`now` [ERROR] THRESHOLD must be greater than 0 and less than 100. Actual is $THRESHOLD"
    exit 1
  fi

  touch $LOG

  if [ $? -ne 0 ]; then
    echo "`now` [ERROR] Can't make $LOG [CODE=$?]" >&2
    exit 1
  fi
}

# }}}
# {{{ mountpath()

mountpath() {
  if [ "$SKIP_MOUNT" = "1" ]; then
    return 0
  fi

  if [ ! "`mount | grep $MOUNT_PATH`" ]; then
    mount $MOUNT_PATH

    if [ $? -ne 0 ]; then
      echo "`now` [ERROR] Can't mount $MOUNT_PATH [CODE=$?]" >&2
      myexit 1
    fi
  fi
}

# }}}
# {{{ mktargetdir()

mktargetdir() {
  TARGET_DIR=`date '+%Y%m%dW%UT%H%M%S'`

  mkdir $TARGET_PATH/$TARGET_DIR

  if [ $? -ne 0 ]; then
    echo "`now` [ERROR] Can't make $TARGET_PATH/$TARGET_DIR [CODE=$?]" >&2
    myexit 1
  fi
}

# }}}
# {{{ chkinterruption()

chkinterruption() {
  if [ -f /var/lock/subsys/backup ]; then
    LATEST=`ls -1 $TARGET_PATH | tail -2 | head -1`

    echo "`now` [NOTICE] The previous backup was interrupted."

    # if $TARGET_PATH and $LATEST are blank, rm -rf / is called!
    if [ "$TARGET_PATH" != "" -a "$LATEST" != "" ]; then
      echo "`now` [NOTICE] Removing $TARGET_PATH/$LATEST..."
      rm -rf $TARGET_PATH/$LATEST
    else
      echo "`now` [ERROR] Runtime error [CODE=002]" >&2
      myexit 1
    fi
  fi
}

# }}}
# {{{ singleton()

singleton() {
  if [ -f /var/lock/subsys/backup.tmp ]; then
    echo "`now` [ERROR] Another backup might be running"
    echo "`now` [ERROR] Remove /var/lock/subsys/backup.tmp if not"
    myexit 1
  fi
}

# }}}
# {{{ dorsync()

dorsync() {
  if [ "$COMPRESSION" == "1" ]; then
    COMPFLAG=z
  fi

  for EXCLUDE in $EXCLUDES; do
    EXCLUDE_OPTIONS="$EXCLUDE_OPTIONS --exclude $EXCLUDE"
  done

  EXCLUDE_OPTIONS="$EXCLUDE_OPTIONS --exclude $TARGET_PATH"

  touch /var/lock/subsys/backup.perm
  touch /var/lock/subsys/backup.tmp

  if [ -d $TARGET_PATH/latest ]; then
    rsync -av$COMPFLAG --stats --link-dest=../latest $EXCLUDE_OPTIONS \
      $SOURCE_PATH/ $TARGET_PATH/$TARGET_DIR
  else
    rsync -av$COMPFLAG --stats $EXCLUDE_OPTIONS \
      $SOURCE_PATH/ $TARGET_PATH/$TARGET_DIR
  fi

  # 24: Partial transfer due to vanished source files
  if [ $? -ne 0 -a $? -ne 24 ]; then
    echo "`now` [ERROR] Can't rsync [CODE=$?]" >&2
    myexit 1
  else
    OK_SYNC=1
  fi
}

# }}}
# {{{ mklatest()

mklatest() {
  cd $TARGET_PATH && rm -f latest && ln -s $TARGET_DIR latest && cd -

  if [ $? -ne 0 ]; then
    echo "`now` [ERROR] Can't make $TARGET_PATH/latest [CODE=$?]" >&2
    myexit 1
  fi

  rm -f /var/lock/subsys/backup.perm
}

# }}}
# {{{ purgeexcess()

purgeexcess() {
  # should set from $TARGET_DIR instead of date command because $TARGET_DIR
  # date might be diffrent from date command when this script is started
  # just before 0:00 midnight.
  NOW_YEAR=`expr substr $TARGET_DIR 1 4`
  NOW_MONTH=`expr substr $TARGET_DIR 5 2`
  NOW_DAY=`expr substr $TARGET_DIR 7 2`

  LASTMONTH_YEAR=`date --date "$NOW_YEAR-$NOW_MONTH-$NOW_DAY 1 months ago" '+%Y'`
  LASTMONTH_WEEK=`date --date "$NOW_YEAR-$NOW_MONTH-$NOW_DAY 1 months ago" '+%U'`

  for DIR in `ls $TARGET_PATH | egrep -v "$TARGET_DIR|latest"`; do
    if [ ! -d $TARGET_PATH/$DIR ]; then
      # $DIR was already purged by this function
      continue
    fi

    DIR_YEAR=`expr substr $DIR 1 4`
    DIR_WEEK=`expr substr $DIR 10 2`
    DIR_DATE=`expr substr $DIR 1 8`

    if [ $DIR_YEAR -lt $LASTMONTH_YEAR ]; then
      OLDEST=`ls -d $TARGET_PATH/$DIR_YEAR*W$DIR_WEEK* | head -1`

      PURGED_DIR=`ls -d $TARGET_PATH/$DIR_YEAR*W$DIR_WEEK* | grep -v $OLDEST`
    elif [ $DIR_YEAR -eq $LASTMONTH_YEAR -a $DIR_WEEK -le $LASTMONTH_WEEK ]; then
      OLDEST=`ls -d $TARGET_PATH/$DIR_YEAR*W$DIR_WEEK* | head -1`

      PURGED_DIR=`ls -d $TARGET_PATH/$DIR_YEAR*W$DIR_WEEK* | grep -v $OLDEST`
    else
      # $DIR was created within 1 month from now on

      OLDEST=`ls -d $TARGET_PATH/$DIR_DATE* | head -1`

      PURGED_DIR=`ls -d $TARGET_PATH/$DIR_DATE* | grep -v $OLDEST`
    fi

    for DIR in $PURGED_DIR; do
      if [ $DIR == $TARGET_PATH/$TARGET_DIR ]; then
        # Don't purge the just created directory
        continue
      fi

      # if $TARGET_PATH is blank, rm -rf / might be called!
      if [ "$TARGET_PATH" != "" ]; then
        echo "`now` [NOTICE] Purging $DIR..."
        rm -rf $DIR
      else
        echo "`now` [ERROR] Runtime error [CODE=003]" >&2
        myexit 1
      fi
    done
  done
}

# }}}
# {{{ purgeold()

purgeold() {
  CURRENT_USAGE=`df -P | grep $MOUNT_PATH | awk '{print $5}' | sed 's/%//'`
  CURRENT_INODE=`df -iP | grep $MOUNT_PATH | awk '{print $5}' | sed 's/%//'`

  while [ $CURRENT_USAGE -gt $THRESHOLD ]; do
    OLDEST=`ls $TARGET_PATH | head -1`

    if [ $OLDEST == $TARGET_DIR ]; then
      echo "`now` [ERROR] Only one backup set but no disk free space" >&2
      myexit 1
    else
      echo "`now` [NOTICE] Disk usage must be under $THRESHOLD% but $CURRENT_USAGE% now"

      # if $TARGET_PATH and $OLDEST are blank, rm -rf / is called!
      if [ "$TARGET_PATH" != "" -a "$OLDEST" != "" ]; then
        echo "`now` [NOTICE] Purging $TARGET_PATH/$OLDEST..."
        rm -rf $TARGET_PATH/$OLDEST
      else
        echo "`now` [ERROR] Runtime error [CODE=004]" >&2
        myexit 1
      fi

      CURRENT_USAGE=`df -P | grep $MOUNT_PATH | awk '{print $5}' | sed 's/%//'`
    fi
  done

  while [ $CURRENT_INODE -gt $THRESHOLD ]; do
    OLDEST=`ls $TARGET_PATH | head -1`

    if [ $OLDEST == $TARGET_DIR ]; then
      echo "`now` [ERROR] Only one backup set but no disk free inode" >&2
      myexit 1
    else
      echo "`now` [NOTICE] Used disk inode must be under $THRESHOLD% but $CURRENT_INODE% now"

      # if $TARGET_PATH and $OLDEST are blank, rm -rf / is called!
      if [ "$TARGET_PATH" != "" -a "$LATEST" != "" ]; then
        echo "`now` [NOTICE] Purging $TARGET_PATH/$OLDEST..."
        rm -rf $TARGET_PATH/$OLDEST
      else
        echo "`now` [ERROR] Runtime error [CODE=005]" >&2
        myexit 1
      fi

      CURRENT_INODE=`df -P | grep $MOUNT_PATH | awk '{print $5}' | sed 's/%//'`
    fi
  done
}

# }}}
# {{{ Trap

trap 'myexit 1' 1 2 3 15

# }}}
# {{{ Default conf

SOURCE_PATH=
MOUNT_PATH=
TARGET_PATH=
SKIP_MOUNT=0
COMPRESSION=1
EXCLUDES="/cgroup /dev /lost+found /media /mnt /proc /selinux /srv /sys cache/ Cache/ tmp/"
THRESHOLD=95
LOG=/var/log/backup.log

# }}}
# {{{ Main

if [ -f /etc/backup.conf ]; then
  . /etc/backup.conf
else
  echo "`now` [ERROR] /etc/backup.conf is not found" >&2
  exit 1
fi

validconf >&2

echo "`now` [NOTICE] Backup begins" >> $LOG

mountpath >> $LOG

chkinterruption >> $LOG

mktargetdir >> $LOG

singleton >> $LOG

dorsync >> $LOG

mklatest >> $LOG

purgeexcess >> $LOG

purgeold >> $LOG

myexit 0 >> $LOG

# }}}
