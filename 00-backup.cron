#!/bin/sh
######################################################################
# @(#) rsync like Time Machine
#
# This script backs up a source directory to local another directory
# by rsync. It supports history and reduce size by hard link like
# Mac OS's Time Machine.
#
#  Author: Tats SHIBATA
# Licenct: http://rewse.jp/license/2011.01.txt
#
# Copyright (c) 2006, 2011 Rewse Lab. All rights reserved.
#
######################################################################
# {{{ Variables

# backup source
SOURCE_PATH=/

# backup target
TARGET_PATH=/var/bak/rsync/charlie

# the script mounts before rsync and unmounts after rsync
# skip mount/unmount if not set
MOUNT_PATH=/var/bak

# do rsync excluding these
EXCLUDES="/dev /lost+found /media /mnt /proc /selinux /srv /sys cache/ tmp/ /var/bak /var/lib/xen"

# purge some oldest backup sets if disk usage % is greater than this
THRESHOLD=95

# script log
LOG=/var/log/backup.log

# }}}
# {{{ umountpath()

umountpath() {
  if [ "MOUNT_PATH" = "" ]; then
    return 0
  fi

  umount $MOUNT_PATH

  if [ $? -ne 0 ]; then
    echo "[WARNING] Can't unmount $MOUNT_PATH" 1>&2
    # no need exit. it's called from myexit
  fi
}

# }}}
# {{{ myexit()

myexit() {
  umountpath

  cat <<! >> $LOG
[NOTICE] Backup ends: `date`
---------------------------------------------------------------------
!

  exit $1
}

# }}}
# {{{ mountpath()

mountpath() {
  if [ "MOUNT_PATH" = "" ]; then
    return 0
  fi

  if [ ! "`mount | grep $MOUNT_PATH`" ]; then
    mount $MOUNT_PATH

    if [ $? -ne 0 ]; then
      echo "[ERROR] Can't mount $MOUNT_PATH" 1>&2
      myexit 1
    fi
  fi
}

# }}}
# {{{ mktargetdir()

mktargetdir() {
  TARGET_DIR=`date '+%Y%m%dW%VT%H%M%S'`

  mkdir -p $TARGET_PATH/$TARGET_DIR

  if [ $? -ne 0 ]; then
    echo "[ERROR] Can't make $TARGET_PATH/$TARGET_DIR" 1>&2
    myexit 1
  fi
}

# }}}
# {{{ dorsync

dorsync() {
  for EXCLUDE in $EXCLUDES; do
    EXCLUDE_OPTIONS="$EXCLUDE_OPTIONS --exclude $EXCLUDE"
  done

  EXCLUDE_OPTIONS="$EXCLUDE_OPTIONS --exclude $TARGET_PATH"

  if [ -d $TARGET_PATH/latest ]; then
    rsync -avz --stats --link-dest=../latest $EXCLUDE_OPTIONS \
      $SOURCE_PATH/ $TARGET_PATH/$TARGET_DIR
  else
    rsync -avz --stats $EXCLUDE_OPTIONS \
      $SOURCE_PATH/ $TARGET_PATH/$TARGET_DIR
  fi

  if [ $? -ne 0 ]; then
    echo "[ERROR] Can't rsync" 1>&2
    myexit 1
  fi
}

# }}}
# {{{ mklatest()

mklatest() {
  cd $TARGET_PATH && rm -f latest && ln -s $TARGET_DIR latest && cd -

  if [ $? -ne 0 ]; then
    echo "[ERROR] Can't make $TARGET_PATH/latest" 1>&2
    myexit 1
  fi
}

# }}}
# {{{ purgeexcess()

purgeexcess() {
  # should set from $TARGET_DIR instead of date command because $TARGET_DIR
  # date might be diffrent from date command when this script is started
  # just before 0:00 midnight.
  NOW_YEAR=`expr substr $TARGET_DIR 1 4`
  NOW_MONTH=`expr substr $TARGET_DIR 5 2`
  NOW_DAY=`expr substr $TARGET_DIR 7 2`

  LASTMONTH_YEAR=`date --date "$NOW_YEAR-$NOW_MONTH-$NOW_DAY 1 months ago" '+%Y'`
  LASTMONTH_WEEK=`date --date "$NOW_YEAR-$NOW_MONTH-$NOW_DAY 1 months ago" '+%V'`

  for DIR in `ls $TARGET_PATH | egrep -v "$TARGET_DIR|latest"`; do
    if [ ! -d $TARGET_PATH/$DIR ]; then
      # $DIR was already purged by this function
      continue
    fi

    DIR_YEAR=`expr substr $DIR 1 4`
    DIR_WEEK=`expr substr $DIR 10 2`
    DIR_DATE=`expr substr $DIR 1 8`

    if [ $DIR_YEAR -lt $LASTMONTH_YEAR ]; then
      OLDEST=`ls -d $TARGET_PATH/$DIR_YEAR*W$DIR_WEEK* | head -1`

      PURGED_DIR=`ls -d $TARGET_PATH/$DIR_YEAR*W$DIR_WEEK* | grep -v $OLDEST`
    elif [ $DIR_YEAR -eq $LASTMONTH_YEAR -a $DIR_WEEK -le $LASTMONTH_WEEK ]; then
      OLDEST=`ls -d $TARGET_PATH/$DIR_YEAR*W$DIR_WEEK* | head -1`

      PURGED_DIR=`ls -d $TARGET_PATH/$DIR_YEAR*W$DIR_WEEK* | grep -v $OLDEST`
    else
      # $DIR was created within 1 month from now on

      OLDEST=`ls -d $TARGET_PATH/$DIR_DATE* | head -1`

      PURGED_DIR=`ls -d $TARGET_PATH/$DIR_DATE* | grep -v $OLDEST`
    fi

    for DIR in $PURGED_DIR; do
      if [ $DIR == $TARGET_PATH/$TARGET_DIR ]; then
        # Don't purge the just created directory
        continue
      fi

      echo "[NOTICE] Purging $DIR..."
      rm -rf $DIR
    done
  done
}

# }}}
# {{{ purgeold()

purgeold() {
  CURRENT_USAGE=`df -P | grep $MOUNT_PATH | awk '{print $5}' | sed 's/%//'`
  CURRENT_INODE=`df -iP | grep $MOUNT_PATH | awk '{print $5}' | sed 's/%//'`

  while [ $CURRENT_USAGE -gt $THRESHOLD ]; do
    OLDEST=`ls $TARGET_PATH | head -1`

    if [ $OLDEST == $TARGET_DIR ]; then
      echo "[ERROR] Only one backup set but no disk free space" 1>&2
      myexit 1
    else
      echo "[NOTICE] Disk usage must be under $THRESHOLD% but $CURRENT_USAGE% now"
      echo "[NOTICE] Purging $TARGET_PATH/$OLDEST..."
      rm -rf $TARGET_PATH/$OLDEST

      CURRENT_USAGE=`df -P | grep $MOUNT_PATH | awk '{print $5}' | sed 's/%//'`
    fi
  done

  while [ $CURRENT_INODE -gt $THRESHOLD ]; do
    OLDEST=`ls $TARGET_PATH | head -1`

    if [ $OLDEST == $TARGET_DIR ]; then
      echo "[ERROR] Only one backup set but no disk free inode" 1>&2
      myexit 1
    else
      echo "[NOTICE] Used disk inode must be under $THRESHOLD% but $CURRENT_INODE% now"
      echo "[NOTICE] Purging $TARGET_PATH/$OLDEST..."
      rm -rf $TARGET_PATH/$OLDEST

      CURRENT_INODE=`df -P | grep $MOUNT_PATH | awk '{print $5}' | sed 's/%//'`
    fi
  done
}

# }}}
# {{{ Trap

trap 'myexit 1' 1 2 3 15

# }}}
# {{{ Main

echo "[NOTICE] Backup begins: `date`" >> $LOG 2>&1

mountpath >> $LOG 2>&1

mktargetdir >> $LOG 2>&1

dorsync >> $LOG 2>&1

mklatest >> $LOG 2>&1

purgeexcess >> $LOG 2>&1

purgeold >> $LOG 2>&1

myexit 0

# }}}
